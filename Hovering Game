import java.awt.*;
import java.awt.event.*;
import java.awt.geom.RoundRectangle2D;
import javax.swing.*;

public class Hower extends JPanel implements ActionListener, KeyListener {
    // Window
    static final int W = 800, H = 600;

    // Player
    int px = 100, py = 400, pw = 40, ph = 60;
    double vy = 0;
    boolean left, right;
    boolean onGround = false;

    // Physics
    double gravity = 0.9;
    double hoverGravity = 0.12; // much slower fall when hovering
    double jumpSpeed = 14;
    boolean hoverMode = false; // toggled by H

    // Platforms (x, y, w, h)
    Rectangle[] platforms;

    // Goal (final point)
    Rectangle goal;
    boolean levelComplete = false;

    Timer timer;

    public Hower() {
        setPreferredSize(new Dimension(W, H));
        setBackground(new Color(20, 24, 34));
        setFocusable(true);
        addKeyListener(this);

        platforms = new Rectangle[] {
            new Rectangle(0, H - 50, W, 50),            // ground
            new Rectangle(150, 450, 200, 20),
            new Rectangle(420, 350, 160, 20),
            new Rectangle(620, 250, 140, 20)
        };

        goal = new Rectangle(W - 110, 190, 60, 60); // final goal near top-right

        timer = new Timer(16, this);
        timer.start();
    }

    private void resetGame() {
        px = 100; py = 400; pw = 40; ph = 60;
        vy = 0;
        left = right = false;
        onGround = false;
        hoverMode = false;
        levelComplete = false;
        timer.start();
    }

    @Override
    protected void paintComponent(Graphics g0) {
        super.paintComponent(g0);
        Graphics2D g = (Graphics2D) g0.create();
        // Quality
        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        g.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_LCD_HRGB);

        // Background gradient (spacey)
        GradientPaint bg = new GradientPaint(0, 0, new Color(12, 18, 36), 0, H, new Color(32, 46, 68));
        g.setPaint(bg);
        g.fillRect(0, 0, W, H);

        // Subtle star field for depth
        g.setColor(new Color(255, 255, 255, 40));
        for (int i = 0; i < 40; i++) {
            int sx = (i * 73) % W;
            int sy = (i * 97) % (H - 200);
            g.fillOval(sx, sy, 2, 2);
        }

        // Draw platforms with shadow and gradient
        for (Rectangle p : platforms) {
            // shadow
            g.setColor(new Color(0, 0, 0, 80));
            g.fillRoundRect(p.x + 4, p.y + 6, p.width, p.height, 10, 10);

            // platform body gradient
            GradientPaint gp = new GradientPaint(p.x, p.y, new Color(60, 160, 100), p.x, p.y + p.height, new Color(30, 90, 60));
            g.setPaint(gp);
            g.fillRoundRect(p.x, p.y, p.width, p.height, 10, 10);

            // highlight
            g.setColor(new Color(255, 255, 255, 60));
            g.fillRoundRect(p.x + 6, p.y + 2, Math.max(0, p.width - 12), 6, 6, 6);
        }

        // Draw goal (shiny orb / platform)
        // Glow (fallback implementation using concentric translucent ovals)
        int gx = goal.x + goal.width / 2;
        int gy = goal.y + goal.height / 2;
        int maxR = Math.max(goal.width, goal.height) + 40;
        for (int r = maxR; r > 0; r -= 8) {
            float t = 1f - (float)r / (float)maxR;
            int alpha = (int)(180 * (1f - t)); // stronger alpha toward center
            alpha = Math.max(0, Math.min(180, alpha));
            g.setColor(new Color(255, 200, 80, alpha));
            g.fillOval(gx - r / 2, gy - r / 2, r, r);
        }

        // Orb
        GradientPaint orb = new GradientPaint(goal.x, goal.y, new Color(255, 230, 120), goal.x + goal.width, goal.y + goal.height, new Color(220, 140, 0));
        g.setPaint(orb);
        g.fillOval(goal.x, goal.y, goal.width, goal.height);
        // star icon on orb
        g.setColor(new Color(255, 255, 255, 200));
        int[] xs = {gx, gx - 6, gx + 10, gx - 10, gx + 6};
        int[] ys = {gy - 12, gy + 8, gy - 4, gy - 4, gy + 8};
        g.fillPolygon(xs, ys, xs.length);

        // Draw player (hoverboard) with rounded shape, sheen and shadow
        // shadow
        g.setColor(new Color(0, 0, 0, 90));
        g.fillRoundRect(px + 4, py + ph + 4, pw, 8, 8, 8);

        // body
        RoundRectangle2D body = new RoundRectangle2D.Double(px, py, pw, ph, 12, 12);
        if (hoverMode) {
            GradientPaint gp = new GradientPaint(px, py, new Color(80, 230, 240), px, py + ph, new Color(30, 150, 200));
            g.setPaint(gp);
        } else {
            GradientPaint gp = new GradientPaint(px, py, new Color(255, 160, 60), px, py + ph, new Color(220, 100, 20));
            g.setPaint(gp);
        }
        g.fill(body);

        // board
        g.setColor(new Color(40, 40, 40));
        g.fillRoundRect(px - 10, py + ph - 6, pw + 20, 14, 12, 12);

        // sheen
        g.setColor(new Color(255, 255, 255, 90));
        g.fillRoundRect(px + 6, py + 6, pw - 12, 8, 8, 8);

        // Small thruster effect if hovering
        if (hoverMode) {
            GradientPaint flame = new GradientPaint(px + pw / 2f, py + ph + 0f, new Color(80, 230, 240, 160), px + pw / 2f, py + ph + 30f, new Color(0, 120, 200, 0));
            g.setPaint(flame);
            g.fillOval(px + pw / 2 - 10, py + ph, 20, 30);
        }

        // HUD
        g.setFont(new Font("SansSerif", Font.BOLD, 14));
        g.setColor(new Color(230, 230, 230));
        g.drawString("Left/Right: ← → or A/D   Jump: Z/up   Toggle Hover: H   Restart: R", 12, 22);
        g.setColor(new Color(180, 240, 255));
        g.drawString("Hover: " + (hoverMode ? "ON" : "OFF"), 12, 44);
        g.setColor(new Color(180, 240, 180));
        g.drawString("On Ground: " + onGround, 12, 66);

        // If completed, draw overlay
        if (levelComplete) {
            g.setColor(new Color(0, 0, 0, 150));
            g.fillRect(0, 0, W, H);

            g.setFont(new Font("SansSerif", Font.BOLD, 48));
            g.setColor(new Color(255, 240, 200));
            String msg = "CONGRATULATIONS!";
            FontMetrics fm = g.getFontMetrics();
            int mx = (W - fm.stringWidth(msg)) / 2;
            int my = H / 2 - 20;
            g.drawString(msg, mx, my);

            g.setFont(new Font("SansSerif", Font.PLAIN, 20));
            String sub = "You reached the goal. Press R to restart.";
            fm = g.getFontMetrics();
            g.setColor(new Color(220, 220, 220));
            g.drawString(sub, (W - fm.stringWidth(sub)) / 2, my + 40);
        }

        g.dispose();
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        if (levelComplete) {
            // freeze everything but keep repainting for glow/overlay
            repaint();
            return;
        }

        // Horizontal movement
        int speed = 5;
        if (left) px -= speed;
        if (right) px += speed;

        // Apply gravity
        double gAcc = hoverMode ? hoverGravity : gravity;
        vy += gAcc;
        py += (int)Math.round(vy);

        // Player rectangle and simple collision with goal first
        Rectangle playerRect = new Rectangle(px, py, pw, ph);
        if (playerRect.intersects(goal)) {
            levelComplete = true;
            // optionally stop movement
            vy = 0;
            repaint();
            return;
        }

        // Simple collision with platforms
        onGround = false;
        for (Rectangle p : platforms) {
            if (playerRect.intersects(p)) {
                Rectangle inter = playerRect.intersection(p);
                // If coming from above, place on top
                if (py < p.y && inter.height > 0) {
                    py = p.y - ph;
                    vy = 0;
                    onGround = true;
                } else if (py > p.y) {
                    // Hitting from below - push down
                    py = p.y + p.height;
                    vy = 0;
                }
                playerRect = new Rectangle(px, py, pw, ph);
            }
        }

        // Keep within bounds
        if (px < 0) px = 0;
        if (px + pw > W) px = W - pw;
        if (py + ph > H) {
            py = H - ph;
            vy = 0;
            onGround = true;
        }

        repaint();
    }

    // Key handling
    @Override
    public void keyPressed(KeyEvent e) {
        int k = e.getKeyCode();
        if (k == KeyEvent.VK_LEFT || k == KeyEvent.VK_A) left = true;
        if (k == KeyEvent.VK_RIGHT || k == KeyEvent.VK_D) right = true;

        if (k == KeyEvent.VK_Z || k == KeyEvent.VK_UP) {
            if (onGround && !levelComplete) {
                vy = -jumpSpeed;
                onGround = false;
            }
        }

        if (k == KeyEvent.VK_H) {
            if (!levelComplete) hoverMode = !hoverMode;
        }

        if (k == KeyEvent.VK_R) {
            resetGame();
        }
    }

    @Override
    public void keyReleased(KeyEvent e) {
        int k = e.getKeyCode();
        if (k == KeyEvent.VK_LEFT || k == KeyEvent.VK_A) left = false;
        if (k == KeyEvent.VK_RIGHT || k == KeyEvent.VK_D) right = false;
    }

    @Override
    public void keyTyped(KeyEvent e) { }

    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            JFrame f = new JFrame("Hower Board Jump Toggle");
            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            f.setResizable(false);
            Hower game = new Hower();
            f.add(game);
            f.pack();
            f.setLocationRelativeTo(null);
            f.setVisible(true);
        });
    }
}
